## 목차
1. 정수와 실수의 차이  
2. 실수도 결국 자리값의 합  
   2-1. 10진수 소수점 아래의 의미  
   2-2. 2진수 소수점 아래의 의미  
3. 10진수 실수를 2진수로 바꾸는 방법  
   3-1. 큰 자리부터 채워 넣는 방식  
   3-2. 곱하기 2를 반복하는 방식  
4. 왜 0.1은 정확히 표현되지 않는가  
5. 고정 소수점 — 소수점 위치를 고정한다  
   5-1. 개념과 장점  
   5-2. 한계와 문제점  
6. 부동 소수점 — 소수점이 움직이는 표현  
   6-1. 아이디어와 장점  
   6-2. 오차가 생기는 이유  
7. 과학적 표기법과 유효 숫자  
8. 정확도와 정밀도는 왜 구분해야 할까  
9. 정규화된 과학적 표기법의 의미  

---

## 1. 정수와 실수의 차이

정수는 “세기”에 가깝다.  
10진수 대신 2진수로 셀 뿐이고, 실제로는 **하나씩 증가시키는 구조**다.

문자도 크게 다르지 않다.  
문자를 내부적으로 숫자에 대응시켜서 다루는 방식이었고,  
“이 숫자는 이 문자”라는 약속만 있으면 됐다.

하지만 **실수**부터는 상황이 달라진다.

정수와 정수 사이에는 값이 무한히 존재한다.  
1과 2 사이에는 1.1, 1.2, 1.3…이 있고,  
1과 1.1 사이에도 또 무한히 많은 값이 있다.

그런데 컴퓨터는 비트로만 값을 저장한다.  
비트 수는 유한하다.  
그래서 실수는 **무한한 값을 유한한 그릇에 담아야 하는 문제**가 된다.


---

## 2. 실수도 결국 자리값의 합

### 2-1. 10진수 소수점 아래의 의미

10진수에서 자릿값은 10의 거듭제곱이다.

- 정수부: 10², 10¹, 10⁰  
- 소수부: 10⁻¹, 10⁻², 10⁻³ …

소수점 아래로 내려간다는 건  
**10으로 나눈 값들이 계속 이어진다는 뜻**이다.

즉 소수점은  
플러스 승수와 마이너스 승수를 가르는 경계일 뿐이다.

### 2-2. 2진수 소수점 아래의 의미

2진수도 구조는 완전히 같다.

- 정수부: 2², 2¹, 2⁰  
- 소수부: 2⁻¹, 2⁻², 2⁻³ …

2⁻¹은 0.5,  
2⁻²는 0.25,  
2⁻³은 0.125다.

실수든 정수든  
**“각 자리의 가중치를 더한 것”**이라는 관점은 변하지 않는다.

![](https://velog.velcdn.com/images/diqkraud/post/de4ae588-0c9b-4a35-90a3-a16f02a9bdb8/image.png)


---

## 3. 10진수 실수를 2진수로 바꾸는 방법

### 3-1. 큰 자리부터 채워 넣는 방식

0.625를 예로 들면,

2진 소수 자리값은  
0.5 → 0.25 → 0.125 → … 순서다.

- 0.625 안에 0.5는 들어간다 → 1  
- 남은 값 0.125 안에 0.25는 못 들어간다 → 0  
- 0.125는 딱 들어간다 → 1  

그래서  
0.625 = 0.101(2) 가 된다.

이 방식은 정수에서  
“가장 큰 2의 거듭제곱부터 채운다”는 사고와 같다.

---

### 3-2. 곱하기 2를 반복하는 방식

조금 더 기계적인 방법도 있다.

규칙은 단순하다.

1) 소수에 2를 곱한다  
2) 정수부(0 또는 1)를 기록한다  
3) 소수부만 남겨 다시 2를 곱한다  
4) 반복한다  

예를 들어 0.3125는,

- 0.3125 × 2 = 0.625 → 0  
- 0.625 × 2 = 1.25 → 1  
- 0.25 × 2 = 0.5 → 0  
- 0.5 × 2 = 1.0 → 1  

그래서  
0.3125 = 0.0101(2) 가 된다.

![](https://velog.velcdn.com/images/diqkraud/post/ab6c3b04-110f-4003-81c7-6814d1cb327b/image.png)


---

## 4. 왜 0.1은 정확히 표현되지 않는가

0.1을 같은 방식으로 변환해 보면,  
어느 순간부터 **같은 값이 반복**된다.

0.2 → 0.4 → 0.8 → 1.6 → 0.6 → 1.2 → 0.2 …

즉 0.1은  
2진수로 표현하면 **끝나지 않는 반복 소수**다.

컴퓨터는 비트를 무한히 저장할 수 없다.  
어딘가에서 끊어야 한다.

그 순간부터  
저장되는 값은 0.1이 아니라  
**0.1에 가장 가까운 근사값**이 된다.

그래서 0.1은  
실수 오차를 설명할 때 항상 등장한다.

![](https://velog.velcdn.com/images/diqkraud/post/6f69b07d-7594-4b6f-a9b3-c43042be54b4/image.png)


---

## 5. 고정 소수점 — 소수점 위치를 고정한다

고정 소수점은  
**소수점 위치를 미리 약속하는 방식**이다.

예를 들어  
8비트 중 뒤의 3비트를 소수부로 쓰겠다고 정하면,  
모든 값은 그 기준을 따른다.

### 5-1. 장점

- 특정 범위 안에서는 값이 안정적으로 표현된다  
- 일부 상황에서는 정확한 계산이 필요할 때 유리하다  

### 5-2. 한계

문제는 트레이드오프다.

- 소수부 비트를 늘리면 → 정수 범위가 줄어든다  
- 정수부 비트를 늘리면 → 소수 표현이 거칠어진다  

값의 크기가 크게 달라지는 상황에서는  
하나의 고정 포맷으로 감당하기 어렵다.

또 곱셈 같은 연산 후에는  
정밀도 손실이나 오버플로가 생길 수 있다.

---

## 6. 부동 소수점 — 소수점이 움직이는 표현

부동 소수점은  
**숫자 덩어리는 유지하고, 소수점 위치를 따로 관리**한다.

1234.56이라는 값에서  
소수점을 옮기기만 해도 값의 크기는 크게 바뀐다.
1234.56 → 123.456 → 12345.6
이 방식 덕분에  
아주 큰 수와 아주 작은 수를  
같은 형식으로 표현할 수 있다.


### 6-2. 오차의 대가

대신 부동 소수점은  
오차가 기본적으로 따라온다.

특히 돈처럼  
1원, 1센트 단위가 중요한 값에는 부적합하다.

반면 위치, 좌표, 그래픽 계산처럼  
미세한 오차가 문제되지 않는 경우에는  
매우 효율적이다.

---

## 7. 과학적 표기법과 유효 숫자

과학적 표기법은  
**의미 있는 숫자 × 스케일** 형태다.

여기서 중요한 건 두 가지다.

- 유효 숫자: 실제 의미를 가진 숫자들  
- 지수: 소수점 위치를 복원하기 위한 정보  

부동 소수점은  
이 아이디어를 그대로 가져온 표현 방식이다.

---

## 8. 정확도와 정밀도

- 정확도: 참값에 얼마나 가까운가  
- 정밀도: 반복 결과가 얼마나 모여 있는가  

둘은 비슷해 보이지만 완전히 다른 개념이다.

ex= 정확도/정밀도를 과녁으로 비교한 이미지 넣는 곳  
이유: 말보다 그림이 훨씬 직관적이다.

실수 오차를 말할 때  
이 둘을 구분하지 않으면  
문제의 원인을 헷갈리기 쉽다
![](https://velog.velcdn.com/images/diqkraud/post/ea17f8ab-f964-4dbe-ab0a-da0dbee81cdc/image.png)



---

## 9. 정규화된 과학적 표기법

정규화는  
모든 값을 **비슷한 형태로 맞추는 규칙**이다.

유효 숫자의 첫 자리를  
항상 정수부 한 자리로 만들고,  
나머지는 소수점 아래로 보낸다.

2진수에서는  
유효 숫자의 첫 자리가 항상 1이 된다.

이 특징은  
부동 소수점 설계를 단순하게 만들어 준다.

---

## 정리

- 실수는 정수처럼 단순히 “세는 방식”으로 표현할 수 없다. 값이 무한히 많기 때문이다.  
- 2진수에서도 소수점 아래는 `2^-1, 2^-2, ...` 가중치로 표현된다.  
- 10진수 실수를 2진수 실수로 바꾸는 대표 방법은 “큰 단위부터 채우기”와 “×2 반복”이다.  
- 0.1은 2진수에서 끝나지 않아, 비트 수가 제한된 컴퓨터에서는 근사 저장이 필연이다.  
- 고정 소수점은 소수점 위치를 고정해 안정성을 얻지만, 범위/정밀도 트레이드오프가 크다.  
- 부동 소수점은 소수점 위치를 지수로 관리해서 범위를 크게 넓히지만, 오차가 기본으로 따라온다.  
- 유효 숫자는 “의미 있는 자리”를 뜻하고, 정확도/정밀도는 실수 오차를 해석하는 기준이 된다.  
- 정규화는 표현을 규격화해 표준 설계를 가능하게 만든다.

