


컴퓨터는 내부에서 모든 데이터를 **2진수(bit)** 로 처리한다.  
하지만 사람이 직접 다루기에는 2진수는 너무 길고 읽기 어렵다.

그래서 컴퓨터 공학에서는  
**2진수를 기준으로**, 사람이 읽기 쉬운 다른 진법들을 함께 사용한다.

이 글에서는  
2진수, 8진수, 16진수, 그리고 32·64진법이  
**어떤 관계로 연결되어 있는지**를 구조 중심으로 정리한다.

---

## 목차
1. 2진수가 모든 진법의 기준이 되는 이유  
2. 비트 수와 표현 가능한 값의 개수  
3. 16진수와 비트 구조의 정확한 대응  
4. 왜 16진수가 실무에서 가장 많이 쓰일까  
5. 8진법이 점점 사라진 이유  
6. 32진법과 64진법의 사용 목적  
7. 전체 정리  

---

## 1. 2진수가 모든 진법의 기준이 되는 이유

컴퓨터의 가장 작은 정보 단위는 **비트(bit)** 다.  
비트 하나는 두 가지 상태만 표현할 수 있다.

| 상태 | 의미 |
| --- | --- |
| 0 | 전류가 흐르지 않음 |
| 1 | 전류가 흐름 |

이 단순한 구조 때문에  
컴퓨터에서 모든 데이터 표현은 **2진수**를 기준으로 설계된다.

---

## 2. 비트 수와 표현 가능한 값의 개수

비트의 개수가 늘어나면  
표현할 수 있는 값의 개수는 다음 규칙을 따른다.
`
비트 n개 → 2^n개의 값
`
yaml
코드 복사

예를 들어,

| 비트 수 | 표현 가능한 값 |
| --- | --- |
| 1비트 | 2 |
| 2비트 | 4 |
| 3비트 | 8 |
| 4비트 | 16 |
| 8비트 | 256 |

이 규칙 하나로  
모든 진법 간의 관계를 설명할 수 있다.

---

## 3. 16진수와 비트 구조의 정확한 대응

### 3.1 왜 16진수는 4비트인가

16진수는 한 자리에 **16가지 값**을 표현한다.

| 16진수 | 값 |
| --- | --- |
| 0 ~ 9 | 0 ~ 9 |
| A ~ F | 10 ~ 15 |

이는 다음과 정확히 일치한다.

`2^4 = 16`


즉,

- **16진수 한 자리 = 4비트**

이 관계는 외워야 할 공식이 아니라  
비트 구조에서 자연스럽게 나온 결과다.

---

### 3.2 16진수 두 자리는 1바이트

컴퓨터에서 메모리를 다루는 기본 단위는 **1바이트(8비트)** 다.

| 표현 | 비트 수 |
| --- | --- |
| 16진수 1자리 | 4비트 |
| 16진수 2자리 | 8비트 (1바이트) |

그래서 메모리 덤프나 헥스 에디터에서는  
다음과 같은 형태가 자주 보인다.

`7E A3 FF 10`

공백 하나가 곧 **1바이트**를 의미한다.

같은 내용을 2진수로 보면 훨씬 길어진다.

`01111110 10100011 11111111 00010000`


---

## 4. 왜 16진수가 실무에서 가장 많이 쓰일까

### 4.1 가독성 관점

2진수는 구조적으로는 명확하지만  
사람이 직접 읽기에는 불편하다.

- 자릿수가 너무 길다
- 비트 경계를 한눈에 파악하기 어렵다

반면 16진수는 다음 장점을 가진다.

- 4비트 단위로 정확히 끊어진다
- 2자리 = 1바이트라는 명확한 대응
- 길이가 짧고 시각적으로 읽기 쉽다

그래서 컴퓨터 내부 표현을  
사람에게 보여줄 때 16진수가 가장 적합하다.

---

### 4.2 색상 코드와 16진수

웹에서 자주 보는 색상 코드 예시는 다음과 같다.

`#FFFFFF`


이는 **16진수 기반 RGB 표현**이다.

| 색상 | 값 |
| --- | --- |
| R | FF → 255 |
| G | FF → 255 |
| B | FF → 255 |

각 색상 값은 **1바이트(8비트)** 로 표현된다.

`0 ~ 255 = 2^8`


여기서도 다시 한 번 확인할 수 있다.

- **1바이트 = 8비트 = 16진수 2자리**

---

## 5. 8진법이 점점 사라진 이유

8진수는 다음 관계를 가진다.

`2^3 = 8`


즉,

- 8진수 한 자리 = 3비트

문제는 컴퓨터의 데이터 접근 단위다.

| 항목 | 값 |
| --- | --- |
| 메모리 접근 단위 | 8비트 |
| 8진수 비트 단위 | 3비트 |

8비트는 3의 배수가 아니기 때문에  
바이트 경계와 맞지 않는다.

그 결과,

- 데이터가 애매하게 끊기고
- 실무에서 사용하기 불편해졌다

이 때문에 현대 컴퓨터 구조에서는  
8진법이 거의 사용되지 않는다.

---

## 6. 32진법과 64진법의 사용 목적

### 6.1 비트 수 관점

| 진법 | 비트 수 |
| --- | --- |
| 32진법 | 5비트 (2^5) |
| 64진법 | 6비트 (2^6) |

이 역시 8비트와 정확히 맞지 않는다.  
그래서 메모리 표현에는 적합하지 않다.

---

### 6.2 문자열과 전송 최적화

32진법과 64진법은  
메모리 저장이 아니라 **문자열 길이를 줄이기 위한 목적**으로 사용된다.

대표적인 예시는 다음과 같다.

- Base64 인코딩
- URL-safe 데이터
- 바이너리 데이터를 문자열로 변환할 때

같은 데이터를 표현해도

| 방식 | 길이 |
| --- | --- |
| 2진수 | 매우 김 |
| 16진수 | 중간 |
| 64진수 | 가장 짧음 |

---

## 7. 전체 정리

- 모든 진법의 기준은 **2진수**다
- 비트 수는 표현 가능한 값의 개수를 결정한다
- 16진수는 바이트 단위와 가장 잘 맞는다
- 8진수는 바이트 경계 문제로 잘 쓰이지 않는다
- 32·64진법은 전송과 표현 최적화를 위해 사용된다

진법은 계산을 위한 도구라기보다  
**같은 비트 패턴을 어떻게 읽을 것인가에 대한 선택**이다.