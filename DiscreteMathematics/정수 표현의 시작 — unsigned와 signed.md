


## 목차
1. 컴퓨터에서 숫자는 어떻게 의미를 갖는가  
2. 정수라는 개념 다시 보기  
3. 부호 없는 정수(unsigned integer)  
4. 비트 수와 표현 가능한 범위  
5. 부호 없는 정수의 덧셈과 오버플로  
6. 부호 있는 정수(signed integer)의 필요성  
7. 부호 비트와 표현 범위의 변화  
8. 부호 절댓값 표현법(signed magnitude)  
9. 부호 절댓값 표현의 한계  
10. 전체 정리

---

## 1. 컴퓨터에서 숫자는 어떻게 의미를 갖는가

컴퓨터 내부에는 문자, 색상, 소리 같은 개념이 없다.  
모든 정보는 비트, 즉 `0`과 `1`의 조합으로 저장된다.

같은 비트 패턴이라도  
우리가 **어떤 방식으로 해석하느냐**에 따라 전혀 다른 의미가 된다.

> 컴퓨터의 값은 항상 숫자이고, 의미는 해석 방식이 결정한다.

정수 표현은 그 해석 방식 중 하나다.

---

## 2. 정수라는 개념 다시 보기

정수(integer)는  
`…, -2, -1, 0, 1, 2, …` 처럼 일정한 간격으로 나열된 수다.

프로그래밍에서 사용하는 `int` 타입이 바로 이 정수를 의미한다.

정수는 다음 세 가지로 나뉜다.

- 양의 정수  
- 0  
- 음의 정수  

이때 중요한 차이가 하나 생긴다.  
**음수를 포함하느냐, 포함하지 않느냐**다.

---

## 3. 부호 없는 정수 (unsigned integer)

`unsigned`는 부호(sign)가 없다는 뜻이다.

즉,
- 0과 양의 정수만 표현 가능
- 음수는 표현 불가능

지금까지 다뤘던 대부분의 2진수 예제는 모두 여기에 해당한다.

---

## 4. 비트 수와 표현 가능한 범위

부호 없는 정수에서 핵심은 이것이다.

> 비트 수가 정해지면 표현 가능한 수의 개수도 정해진다.

비트가 `n`개라면 표현 가능한 값의 개수는 `2^n`개다.

예를 들어,
- 8비트: `2^8 = 256`개 → `0 ~ 255`
- 16비트: `2^16 = 65536`개 → `0 ~ 65535`

0을 포함하므로 **최댓값은 항상 `2^n - 1`**이 된다.

---

## 5. 부호 없는 정수의 덧셈과 오버플로

![](https://velog.velcdn.com/images/diqkraud/post/f0220a2f-fa76-4bcf-b51e-1a3221571a9c/image.png)


8비트 부호 없는 정수의 최댓값은 `255`이다.  
이를 2진수로 표현하면 `11111111`이다.

여기에 `1`을 더하면 다음과 같은 일이 발생한다.

- 기존 값: `11111111`
- 1을 더하면: `100000000`

결과는 9비트가 필요하다.  
하지만 우리는 **8비트만 사용하기로 이미 정해두었다**.

그래서 가장 앞의 `1`은 저장되지 않고 버려진다.  
결과적으로 실제 저장되는 값은 `00000000`이다.

이 현상을 **오버플로(overflow)**라고 한다.

> 표현 가능한 범위를 넘는 값은 저장되지 않고 버려진다.

그래서 부호 없는 정수에서는  
최댓값을 넘기면 다시 0으로 돌아간다.

이 현상은 진법과 무관하게  
자릿수를 고정하면 항상 발생한다.

---

## 6. 부호 있는 정수 (signed integer)의 필요성

이제 음수를 표현해야 하는 상황을 생각해보자.

사람은 숫자 앞에 `+`, `-` 기호를 붙이면 끝이지만  
컴퓨터는 `0`과 `1`만 사용할 수 있다.

그래서 나온 아이디어가 이것이다.

> 가장 앞의 비트를 부호로 사용하자.

---

## 7. 부호 비트와 표현 범위의 변화

8비트 정수에서  
가장 왼쪽 비트(MSB)를 부호 비트로 사용한다.

- 부호 비트가 `0`이면 양수  
- 부호 비트가 `1`이면 음수  

그러면 실제 숫자를 표현하는 비트는 7개만 남는다.

즉,
- 표현 가능한 개수: `2^7 = 128`
- 양수 128개, 음수 128개

> 부호를 허용하는 순간, 표현 범위는 절반으로 줄어든다.

---

## 8. 부호 절댓값 표현법 (Signed Magnitude)

가장 직관적인 음수 표현 방식이다.

- 최상위 비트: 부호  
- 나머지 비트: 절댓값  

예를 들면,
- +3 → 부호 `0`, 값 `0000011`
- -3 → 부호 `1`, 값 `0000011`

절댓값 부분은 같고,  
부호 비트만 달라진다.

---

## 9. 부호 절댓값 표현의 한계

이 방식에는 명확한 문제가 있다.

첫째, 0이 두 개 존재한다.
- +0과 -0이 서로 다른 비트 패턴을 가진다.

둘째, 덧셈이 자연스럽지 않다.

예를 들어 `1 + (-1)`을 계산하면,
- 수학적으로는 0이 나와야 하지만
- 비트 단위 덧셈 결과는 -2가 된다.

> 양수와 음수를 섞어 더하면 올바른 결과가 나오지 않는다.

컴퓨터는 기본적으로 **덧셈 중심 구조**다.  
뺄셈조차 덧셈으로 바꿔 처리한다.

이 표현 방식은 그 구조와 맞지 않는다.

그래서 실제 시스템에서는 거의 사용되지 않는다.

---

## 10. 전체 정리

- 컴퓨터는 비트를 어떻게 해석하느냐에 따라 값의 의미가 달라진다.
- 부호 없는 정수는 구조가 단순하고 범위 계산이 쉽다.
- 비트 수가 고정되면 표현 가능한 값의 범위도 고정된다.
- 범위를 넘는 연산 결과는 오버플로로 인해 버려진다.
- 부호 있는 정수는 최상위 비트를 부호로 사용한다.
- 이로 인해 표현 범위는 절반으로 줄어든다.
- 부호 절댓값 표현법은 직관적이지만 연산에 치명적인 문제가 있다.
