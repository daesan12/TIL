
## 목차
1. 보수라는 아이디어가 필요한 이유  
2. 보수의 기본 정의  
3. 10의 보수와 9의 보수  
4. 보수로 뺄셈을 덧셈으로 바꾸는 흐름  
5. 고정 자릿수, 오버플로, 그리고 “도돌이표”  
6. 2진법의 보수: 1의 보수  
7. 1의 보수 방식의 한계  
8. 2의 보수: 표준이 된 이유  
9. 2의 보수로 음수를 만드는 절차  
10. 2의 보수 덧셈에서의 오버플로/언더플로  
11. 뺄셈은 “음수를 더하기”로 처리된다  
12. 2진수 곱셈: 2의 거듭제곱을 곱하는 경우  
13. 비트 시프트와 곱셈의 연결  
14. 일반적인 2진 곱셈(세로셈 방식)  
15. 전체 정리

---

## 1. 보수라는 아이디어가 필요한 이유

정수 계산에서 특히 까다로운 건 음수와 뺄셈이다.  
컴퓨터는 기본적으로 덧셈 중심으로 설계되어 있어서, 뺄셈을 “덧셈으로 바꾸는” 방식이 있으면 계산 규칙이 단순해진다.

> 뺄셈을 덧셈으로 바꿔버리면, 하드웨어 입장에서는 훨씬 편해진다.

이때 등장하는 개념이 보수(complement)다.

---

## 2. 보수의 기본 정의

보수는 “어떤 수와 더했을 때 일정한 기준 값이 되도록 만들어주는 수”다.

진법이 정해지면 보수는 보통 두 가지로 이야기한다.

- `N의 보수`  
- `N-1의 보수`

10진법이라면 각각 `10의 보수`, `9의 보수`가 된다.

---

## 3. 10의 보수와 9의 보수

### 10의 보수
10의 보수는 “다음 자리(10^n)를 만들기 위해 필요한 수”로 이해하는 게 깔끔하다.

- `2`의 10의 보수는 `8` (2 + 8 = 10)
- `7`의 10의 보수는 `3`
- `12`는 한 자리(10)가 아니라 두 자리(100)를 기준으로 봐서 `88`이 된다

정리하면, 자릿수가 `n`일 때 `10의 보수 = 10^n - 원래 수`다.

### 9의 보수
9의 보수는 각 자리에서 “9를 만들기 위해 필요한 수”다.

예를 들어 `483`의 9의 보수는 `516`이다.  
각 자리에서 `9-4`, `9-8`, `9-3`을 하면 된다.

그리고 10의 보수는 9의 보수를 이용해 더 쉽게 구한다.

- 먼저 9의 보수를 구하고  
- 마지막에 `+1`을 하면 된다

---

## 4. 보수로 뺄셈을 덧셈으로 바꾸는 흐름

예를 들어 `320 - 4`를 보수로 처리하면 다음 흐름이 된다.

- `4`를 어떤 기준(여기선 3자리이므로 `1000`)까지 채우는 수를 만든다  
- `4`의 10의 보수는 `996`  
- 따라서 `320 - 4`는 `320 + 996 - 1000`과 같은 구조가 된다  
- 여기서 핵심은 “뺄셈을 덧셈으로 바꿨다”는 점이다

사람이 계산하면 마지막에 `1000`을 제거해야 하지만, **자릿수가 고정된 기계**에서는 이 과정이 더 단순해진다. 

---

## 5. 고정 자릿수, 오버플로, 그리고 “도돌이표”

자릿수가 고정이면, 표현 범위를 넘는 상위 자리는 저장되지 않는다.  
그게 오버플로다. 

예를 들어 5자리 계산기라면, `100316`에서 가장 왼쪽 `1`은 화면에 표시되지 않는다.  
결국 남는 `00316`이 결과처럼 보이게 된다. 

이걸 “원형으로 숫자가 돌고 돈다”는 의미로 도돌이표처럼 설명하기도 한다.

---

## 6. 2진법의 보수: 1의 보수

2진법에서도 보수는 똑같이 존재한다.

- `1의 보수`는 `2^n - 1`을 기준으로 “합이 전부 1이 되도록” 만드는 보수다.
- 2진수는 각 자리가 `0` 또는 `1`뿐이라서, 결과적으로 1의 보수는 “비트를 뒤집는 것”과 동일하게 동작한다. 

즉 `1이면 0`, `0이면 1`로 바꾸면 된다.

---

## 7. 1의 보수 방식의 한계

1의 보수 방식은 직관적이지만 깔끔하지 않은 지점이 있다.

- `0`이 두 개 생긴다(표현이 중복되는 문제가 생김)
- 더했을 때 받아올림이 생기는 경우, 결과를 보정하기 위해 추가 규칙이 필요해진다

원하는 건 “0 하나”, “규칙 하나”다. 그래서 2의 보수로 간다.

---

## 8. 2의 보수: 표준이 된 이유

2의 보수는 2진법에서의 `N의 보수`다.  
오늘날 대부분의 CPU/언어에서 부호 있는 정수 표현으로 사용된다.

2의 보수의 장점은 간단하다.

- 0이 하나다
- 뺄셈을 덧셈으로 바꾸는 규칙이 깔끔하다
- 추가 보정 규칙이 거의 필요 없다

---

## 9. 2의 보수로 음수를 만드는 절차

절차는 고정이다. 

1) 1의 보수를 만든다(비트를 뒤집는다)  
2) `+1`을 한다  
그러면 그게 2의 보수다.

예를 들어 8비트에서 `-2`를 만들고 싶으면:

- `2`는 `00000010`
- 비트 뒤집기 → `11111101`
- `+1` → `11111110`

반대로 음수 비트 패턴을 양수로 읽고 싶으면, 동일하게 “뒤집고 +1”을 하면 절댓값이 나온다.{index=24}

---

## 10. 2의 보수 덧셈에서의 오버플로/언더플로
![](https://velog.velcdn.com/images/diqkraud/post/e63ee582-f2cd-431d-8db9-682dbe81468b/image.png)

8비트 부호 있는 정수의 범위는 `-128 ~ 127`이다. 

### 오버플로
최댓값 `127`을 넘으면 다음 값은 `-128` 쪽으로 넘어간다.

### 언더플로
최솟값 `-128`보다 더 내려가면 `127`로 넘어간다. 

부호 없는 정수와 비교하면 차이가 더 명확하다.

- unsigned 8비트: `255` 다음은 `0`
- signed 8비트(2의 보수): `127` 다음은 `-128`

---

## 11. 뺄셈은 “음수를 더하기”로 처리된다

2의 보수를 쓰면 뺄셈을 별도로 구현할 필요가 줄어든다.

- `A - B`는 `A + (-B)`로 처리하면 된다 

양수/음수 조합은 경우가 많아 보여도 결론은 하나다.  
두 번째 피연산자를 적절히 음수로 바꾼 다음 더하면 된다.

---

## 12. 2진수 곱셈: 2의 거듭제곱을 곱하는 경우

2진수에서 가장 쉬운 곱셈은 `2`, `4`, `8`처럼 `2^k`를 곱하는 경우다. 

10진수에서 `×10`, `×100`이 쉬운 이유가 “뒤에 0을 붙이면 되기 때문”인 것처럼,  
2진수에서 `×2`, `×4`도 자릿수만 옮기면 된다.

---

## 13. 비트 시프트와 곱셈의 연결

2진수에서 `2`를 곱하는 건 왼쪽으로 1칸 밀고 `0`을 채우는 것과 같다.  
즉 `<< 1`과 같은 동작이다.

예를 들어 `1101`에 `2(=10)`를 곱하면
- 한 칸 왼쪽으로 이동 → `11010` 

`4(=100)`를 곱하면:
- 두 칸 왼쪽으로 이동 → `10100` 같은 형태가 된다 

> 2진수에서 `2^k`를 곱하는 건 비트 시프트로 처리할 수 있다. 

---

## 14. 일반적인 2진 곱셈(세로셈 방식)

`2^k`가 아닌 일반 곱셈은 10진수 곱셈과 방식이 같다.

예를 들어 `1001`과 `101`을 곱할 때:

- 아래 자리부터 곱한다
- `1`이면 그대로 적고
- `0`이면 0으로 채운 줄을 만들고
- 한 자리씩 옮겨 적은 뒤
- 마지막에 전부 더한다

이 방식은 원리는 중요하지만, 실제로 사람이 자주 손으로 할 일은 많지 않다. 컴퓨터가 해주기 때문이다. 

또한 부호가 섞인 곱셈은, 부호는 따로 처리하고 절댓값끼리 곱한 뒤 부호를 붙이는 식으로 이해할 수 있다. 

---

## 15. 전체 정리

- 보수는 “뺄셈을 덧셈으로 바꾸기 위한” 핵심 아이디어다.
- 자릿수가 고정되면 오버플로가 자연스럽게 발생하고, 이 특성 덕분에 보수 기반 계산이 더 단순해진다.
- 2진법에서 1의 보수는 비트 반전으로 구할 수 있지만, 0 중복과 보정 규칙 문제로 깔끔하지 않다.
- 2의 보수는 `비트 반전 + 1`로 만들며, 0이 하나이고 덧셈 규칙이 일관적이라 표준이 되었다.
- 부호 있는 정수에서는 오버플로/언더플로가 “최댓값↔최솟값”으로 도는 형태로 나타난다.
- 뺄셈은 `A + (-B)`로 바꿔 덧셈으로 처리한다.
- 2진수에서 `2^k` 곱셈은 비트 시프트로 연결되며, 일반 곱셈은 10진수 세로셈과 같은 방식으로 동작한다.
